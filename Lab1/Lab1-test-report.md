# Lab1 test report

## 1. 实验概要

多线程编程是高性能编程的技术之一，实验1将针对数独求解问题比较多线程与单线程的性能差异、同一功能不同代码实现的性能差异以及多线程在不同硬件环境下的性能差异。

### 1.1 程序输入

本项目完成的是Basic Version，程序将在控制台接收用户输入，该输入应为某一目录下的一个数独谜题文件，该文件包含多个数独谜题，每个数独谜题按固定格式存储在该文件中。

### 1.2 程序输出

实验中把数独的解按与输入相对应的顺序输出到**标准输出stdout**

### 1.3 Sudoku算法

选择的是老师提供的舞蹈链算法，即`dance-link`算法。

### 1.4 性能指标

我们在用户按下回车之后获取当前时刻为`start`，待结果全部输出到标准输出之后获取时刻为`end`，则`(end - start)`即为我们程序运行的总时间。

### 1.5 实验环境

采用的VMware下的Ubuntu虚拟机，**Linux内核版本为4.4.0-21-generic，2GB内存，使用4内核（这里应该是4线程的意思）**。

CPU型号为Intel(R) Core(TM) i5-8400U CPU @ 2.80GHz 2.81GHz，2内核4线程。

### 代码实现版本 

实验中共使用两份不同的代码：老师提供的和我们完成的。  
完成的代码：为适应多线程而在 Code1 上进行了一系列的修改和增添而成。在Code2 中，可通过参数的调节而控制线程数量。Code2 共有 2 种不同类型的线程，一相当于生产者进程，负责的是任务的读取和分发，还是就是消费者进程，也就是负责任务的分发的进程。
1.打开终端进入相应的程序文件夹
2.终端输入make指令编译相应程序，生成**sudoku_solve**可执行文件
3.终端输入**./sudoku_solve**运行程序
4.输入相应的输入文件名即可。
## 2. 性能测试

&emsp;&emsp;程序的性能会受到诸多因素的影响，其中包括软件层面的因素和硬件层面的因素。本节将分析比较多线程程序与单线程程序的性能差异、同一功能不同代码实现的性能差异，以及同一个程序在不同硬件环境下的性能差异。

### 2.1 多线程与单线程性能比较

&emsp;&emsp;单线程程序只能利用1个CPU核心，而多线程程序能使CPU的多个核心并行运作，因此，多线程能够充分发挥多核CPU的优势。在一定范围内，加速比会随着线程数的增加而增长，即时间开销越少、效率越高。当线程数超过CPU核心数时，性能会有所下降。

&emsp;&emsp;为了比较多线程与单线程性能差异，实验将提供1个大小为84.0 MB、具有1024 K个数独题的文件，而后分别使用单个sudoku_solve线程和n个sudoku_solve线程分别对该文件内的所有数独题进行求解，并把解写入到文件中，测量这一部分所需要的时间开销并计算加速比。

&emsp;&emsp;图2-1展示了不同线程数对性能造成的影响，其2条折线：**Consumed time**和**Speedup**分别表示随sodoku_solve线程数量的变化所需的时间开销和相应的加速比。从图2-1可以看出，当总线程数小于CPU总核心数时，随着线程数的增加，所需要的时间开销越小、加速比更高。从sudoku_solve线程数为15开始，总线程数（详见1.6）开始超过CPU物理核心数，线程开始被操作系统调度，调度会有一定的开销，所以性能会有所下降。

&emsp;&emsp;在实验中，dispatcher线程按任务量平均分配给各个sudoku_solve线程而没考虑按线程的空闲程度分配，造成最慢的sudoku_solve线程会成为瓶颈。实验中file_read线程和dispatcher线程所需要的时间开销是很小的，CPU资源主要用在了sudoku_solve线程上。当sudoku_slove线程数为15和16时，sudoku_solve线程会被调度，但调度次数不是特别多（因file_read线程和dispatcher占用CPU资源少，并且完成后线程会退出），所以最慢的sudoku_solve线程成为瓶颈的问题不是特别明显。当sudoku_solve线程数从16增加到17时，会有几个因素：各个sudoku_solve线程任务量相当；各个sudoku_solve线程绑定在CPU核心上；线程数超过CPU核心数，因此会有2个sudoku_solve线程绑定同一个CPU核心的现象，瓶颈会出现在这里，即会有较快完成任务的sodoku_solve线程等待较慢的sudoku_solve线程（共享同1个核心的soduku_solve线程必然会比较慢）。因此，在sudoku_solve线程超过16时，会出现性能急剧下降的现象。 

<div align="center"><img src="src/图2-1.png" alt="图2-1" title="图2-1" style="zoom:35%;" /></div>

**<p align="center">图2-1 不同线程数需要的时间开销及相应加速比</p>**

### 2.2 不同代码实现性能比较

&emsp;&emsp;对于实现同一功能的程序，可以有多种不同的代码实现，不同的代码实现在时间开销上不一定会相同。实验中使用的Code2比Code1多了一些额外的代码段，因此Code2的时间开销要略大与Code1，并且随着问题规模的增大，差距也会愈加明显。

&emsp;&emsp;考虑到代码可读性、可扩展性或其他因素，有时会在代码实现上增加一些额外的代码段。当这些额外的代码段被调用的次数足够多时，其所造成的时间开销会逐渐显现出来。

&emsp;&emsp;实验将使用2份不同的代码进行性能比较：Code1和Code2。实验提供8个不同大小的文件，每个文件分别有数独题：1 K,2 K,4 K,8 K,16 K,32 K,64 K,128 K,256 K,512 K和1024 K。分别用Code1和Code2对这些文件进行求解（此处Code1和Code2都是使用单个数独求解线程进行求解），并测量时间开销。

&emsp;&emsp;图2-2显示数独题量从1 K增长到1024 K时，Code1与Code2之间的时间开销差距逐渐拉大。在1024 K时，Code2比Code1多花费了约10 S的时间。因为在代码实现时，Code2比Code1多增加了一些额外的代码，必然会引入一些额外的开销。在这些额外增加的代码中，有些代码段在程序运行期间调用次数不多，有些代码段则是进行1次数独求解就要调用1次，当数独求解量达到1024 K之多时，其所造成的开销就会凸显出来。因而会造成随着数独题量的增多，Code1和Code2在时间花销上差距逐渐明显的现象。

<div align="center"><img src="src/图2-2.png" alt="图2-2" title="图2-2" style="zoom:35%;" /></div>

**<p align="center">图2-2 不同代码实现时间开销对比</p>**

### 2.3 不同硬件环境性能比较

&emsp;&emsp;硬件环境如CPU主频（其它如物理CPU个数、物理核心数等）的不同，会导致同一个程序在不同的硬件环境中有不同的表现。对单个CPU物理核心，其主频越高，运行速度越快。

&emsp;&emsp;实验将使用Code2分别在ENV1和ENV2中对大小为84.0MB、具有1024 K个数独题的文件进行求解，其中sudoku_solve线程数从1开始逐步增加，测量时间开销。

&emsp;&emsp;图2-3为Code2在不同的硬件环境ENV1和ENV2中分别调整不同的sudoku_solve线程数的测试结果。从图2-3可以看出，当sudoku_solve线程数在1～4时，ENV2的时间花销略小于ENV1，因为ENV2的CPU主频为2.6 GHZ，略大于ENV1的主频2.0 GHZ，即对单个物理核心而言，ENV2的运行速度比ENV1快。当sudoku_solve线程数量在5～8时，ENV2的时间开销要略大于ENV1，这是因为ENV2总共只有4个物理核心，通过超线程技术模拟出8个逻辑核心，其单个逻辑核心的性能还是略逊于单个物理核心，但总体上看增加超线程还是会使性能略有提升。在ENV2中，继续增加sudoku_solve线程数量使得线程数超过逻辑核心数（线程数大于8），其性能会因为线程的调度而出现下降的趋势；同理，在ENV1中，继续增加sudoku_solve线程数量使得线程数超过物理核心数（线程数大于16），其性能也会因线程调度而有所下降。

<div align="center"><img src="src/图2-3.png" alt="图2-3" title="图2-3" style="zoom:35%;" /></div>

**<p align="center">图2-3 不同硬件环境时间开销对比</p>**
